package routines;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/*
 * user specification: the function's comment should contain keys as follows: 1. write about the function's comment.but
 * it must be before the "{talendTypes}" key.
 * 
 * 2. {talendTypes} 's value must be talend Type, it is required . its value should be one of: String, char | Character,
 * long | Long, int | Integer, boolean | Boolean, byte | Byte, Date, double | Double, float | Float, Object, short |
 * Short
 * 
 * 3. {Category} define a category for the Function. it is required. its value is user-defined .
 * 
 * 4. {param} 's format is: {param} <type>[(<default value or closed list values>)] <name>[ : <comment>]
 * 
 * <type> 's value should be one of: string, int, list, double, object, boolean, long, char, date. <name>'s value is the
 * Function's parameter name. the {param} is optional. so if you the Function without the parameters. the {param} don't
 * added. you can have many parameters for the Function.
 * 
 * 5. {example} gives a example for the Function. it is optional.
 */
public class SynalticDQ {
	
	/**
	 * @author Geoffrey Mathé
	 * 
	 * Cette fonction permet de normaliser les villes (suppression des accents,mise en majuscule, traitement du cas particulier des villes ayant l'acronyme "ST" pour "SAINT")
	 * 
	 */
	
    public static String NormalizeCity (String city){
    	String newCity = null;
		
    	if(city != null && !"".equals(city)){
    	
    		newCity = java.text.Normalizer.normalize(city, java.text.Normalizer.Form.NFD).replaceAll("[\u0300-\u036F]","").toUpperCase().replaceAll("^ST", "SAINT").replaceAll(" ST ", " SAINT ");
    		
    		
    	}
		
		return newCity;
	}
    
	/**
	 * @author Geoffrey Mathé
	 * 
	 * Cette fonction permet d'extraire le code postal contenu dans une adresse complète
	 * 
	 */
    
	public static String FindPostalCode (String adresse){
		
		
		if(adresse != null && !"".equals(adresse)){
		
			String zipCode ="";
		
			Pattern zipPattern = Pattern.compile("(\\d{5})");
			Matcher zipMatcher = zipPattern.matcher(adresse);
			if (zipMatcher.find()) {
				zipCode = zipMatcher.group(1);
				return zipCode;
			}
			
			return null;
		}
		
		return null;
	}
    
    
	/**
	 * @author Geoffrey Mathé
	 * 
	 * Cette fonction permet de vérifier si les codes postaux sont bien formés et de mettre a null ceux qui ne le sont pas 
	 * 
	 */
    
	public static String NormalizePostalCode (String codepostal){
		String newPostalCode = null;
		
		if(codepostal != null && !" ".equals(codepostal)){
			if(isNumeric(codepostal) && codepostal.length() == 5){
				newPostalCode = codepostal;
			}
		}
	
		return newPostalCode;
	}
	
	
	/**
	 * @author Geoffrey Mathé
	 * 
	 * Cette fonction permet de vérifier si les codes postaux ne contiennent pas de chaine de caractère 
	 * 
	 */
    
    public static Boolean isNumeric(String str) {
    	if(str.equals("")){
    		return false;
    	}
    	for(int i=str.length();--i>=0;){ 
    		int chr=str.charAt(i); 
    		if((chr<48&&chr!=45)|| chr>57) 
    		return false;
    		} 
    		return true;
    }
    
	/**
	 * @author Cédric Rouzeaud
	 * 
	 * Cette fonction permet de standardiser les numéros de téléphone en supprimant les caractères non numérique 
	 * 
	 */    
    
	public static String standardizePhone (String originalPhone) {
		String phoneStandardized = null;

		
		if (originalPhone != null && !("".equals(originalPhone.trim()))) { 
			//phoneStandardized = originalPhone.replaceAll(",", ".");
			phoneStandardized = originalPhone.replaceAll("[^0-9]", "");
		}
	
		return phoneStandardized;
	}    
    
}
